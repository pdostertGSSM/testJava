import java.util.*;

/**
 * The SkyScraper class, here we're assuming we're given an nxn board with
 *  full left/top/right/bottom hints for a traditional game of skyscraper
 *  This is given in the "hints" 2D array (which is 4xn) containing, in order
 *  left, top, right, bottom
 *
 *  For example, if our board is
 *    2   2   3   4   1
 * 2|   |   |   |   |   |1
 * 2|   |   |   |   |   |2
 * 1|   |   |   |   |   |4
 * 2|   |   |   |   |   |3
 * 3|   |   |   |   |   |2
 *    2   2   2   1   4
 *
 * Then our goal is to find the entries 1-5 on each row/column which
 *   solve the board. The solution would be
 *    2   2   3   4   1
 * 2| 4 | 2 | 3 | 1 | 5 |1
 * 2| 1 | 5 | 2 | 3 | 4 |2
 * 1| 5 | 3 | 4 | 2 | 1 |4
 * 2| 2 | 1 | 5 | 4 | 3 |3
 * 3| 3 | 4 | 1 | 5 | 2 |2
 *    2   2   2   1   4
 * n = size of skyscraper puzzle (nxn)
 * hints =  2D array of size 4xn consisting of the hints in order
 *  Left, Top, Right, Bottom (LTRB). For example
 * int hints[][] = {{2,2,1,2,3},{2,2,3,4,1},{1,2,4,3,2},{2,2,2,1,4}};
 */

class SkyScraper{

    public int hints[][];
    int n;

    /**
     * Constructor. Sets n and class variable "hints"
     * @param hints
     */
    public SkyScraper(int [][] hints){
        this.n = hints[0].length;
        this.hints = hints;
    }

    /**
     * Standard overridden equals for our class (autogenerated)
     * @param o
     * @return
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SkyScraper that = (SkyScraper) o;
        return n == that.n && Arrays.equals(hints, that.hints);
    }

    /**
     * checkBoard
     * @param board
     * @return true if board matches all hints, false if not
     */
    public boolean checkBoard(int [][] board){

        int numBuildings = 0;
        int maxSize = 0;
        // Left
        for(int row=0; row<n; ++row) {
            numBuildings = 0;
            maxSize = 0;
            // The left
            // Here we're looping forwards through rows

//            System.out.print("[");
//            for (int r : board[row])
//                System.out.print(r + ",");
//            System.out.println("\b]");

            for (int col = 0; col < n; ++col) {
                if (board[row][col] > maxSize) {
                    maxSize = board[row][col];
                    numBuildings++;
                }
            }

//            System.out.println("R numBuildings" + numBuildings);
//            System.out.println("Hints = "+hints[0][row]);
            if (hints[0][row] != numBuildings)
                return false;
        }

        // Top - add down the row
        for(int col=0; col<n; ++col) {

            numBuildings = 0;
            maxSize = 0;

//            System.out.print("[");
//            for (int c : board[col])
//                System.out.print(c + ",");
//            System.out.println("\b]");

            for (int row = 0; row < n; ++row) {
                if (board[row][col] > maxSize) {
                    maxSize = board[row][col];
                    numBuildings++;
                }
            }

//            System.out.println("T numBuildings" + numBuildings);
            if (hints[1][col] != numBuildings)
                return false;
        }


        // Right
        for(int row=0; row<n; ++row) {
            numBuildings = 0;
            maxSize = 0;
            // The left
            // Here we're looping forwards through rows

//            System.out.print("[");
//            for (int r : board[row])
//                System.out.print(r + ",");
//            System.out.println("\b]");
            // Backwards through columns since right side
            for (int col = n-1; col >=0; --col) {
                if (board[row][col] > maxSize) {
                    maxSize = board[row][col];
                    numBuildings++;
                }
            }

//           System.out.println("L numBuildings" + numBuildings);
            if (hints[2][row] != numBuildings)
                return false;
        }
        // Bottom - add bottom up
        for(int col=0; col<n; ++col) {

            numBuildings = 0;
            maxSize = 0;

//            System.out.print("[");
//            for (int c : board[col])
//                System.out.print(c + ",");
//            System.out.println("\b]");
            // Start bottom add up
            for (int row = n-1; row >=0; --row) {
                if (board[row][col] > maxSize) {
                    maxSize = board[row][col];
                    numBuildings++;
                }
            }

//            System.out.println("B numBuildings" + numBuildings);
            if (hints[3][col] != numBuildings)
                return false;
        }
        return true;
    }

}

/**
 * Skyscraper Solver class. Mine contains
 * perms : n! x n array consisting of every single possible permutation of n elements
 * possibleSolution: nxn array that is a possible solution to be checked
 * origs : This is kind of a temp that I use to hold n-sized 1D arrays that will
 *  go into the perms array
 * howMany : a static int that contains how many elements there are in perms
 *
 * Note: When I generate perms, I don't generate ALL permutations. I generate
 *   only ones that work with some subset of the hints
 */
class SkyscraperSolver{
    public int [][] perms;
    public int [][] possibleSoln;
    public ArrayList<int[][]> allSolns; //Use only for n=6 or more
    int [] origs;
    static int howMany = 0;

    /**
     * factorial - Recursive factorial to find full size of perms
     * @param n
     * @return
     */
    int factorial(int n){
        if( n==1)
            return 1;
        else
            return(n*factorial(n-1));
    }

    /**
     * Constructor. Allocates for both perms and possibleSoln
     * @param n
     */
    SkyscraperSolver(int n){
        perms = new int [factorial(n)][n];
        possibleSoln = new int [n][n];
        allSolns = new ArrayList<int[][]>();
    }

    /**
     * A swap routine that I use for the recursive permutation routine
     * @param x
     * @param i
     * @param j
     */
    void swap(int [] x, int i, int j){
        int temp = x[i];
        x[i] = x[j]; x[j] = temp;
    }

    /**
     * Solver. This just calls loopR... it's a one liner.
     *
     * @param sky
     * @param n
     */

    void solver(SkyScraper sky,int n){
        loopR(sky,0,n);
    }

    // The recursive generator for possible solutions, level represents
    //  the number of entries in each

    /**
     * This is the meat of my code. It recursively "builds" a row of the possible
     *  solution. Basic idea is, say, first row could be
     *  [1 2 3 4 5]
     *  Then this calls itself with "level+1" to generate the next row. It can't
     *   generate anything with a 1 in the first spot, 2 in the second, etc
     *   this continues, recursively generating every possible solution.
     *  Note that you can add in checks along the way to make sure some of the
     *   hints are satisfied to cut down on the brute force checking.
     * @param sky
     * @param level
     * @param n
     */
    void loopR(SkyScraper sky,int level, int n){
        if(level == n && n<=5){
            if(sky.checkBoard(possibleSoln)) {
                for (int[] pp : possibleSoln) {
                    System.out.print("(");
                    for (int p : pp)
                        System.out.print(p + ",");
                    System.out.println("\b)");
                }
                System.out.println("-----------------------");
            }
            return;
        }
        else if(level ==n){
//            System.out.print(".");

            if(sky.checkBoard(possibleSoln)){
                allSolns.add(possibleSoln);
                System.out.println(allSolns.size() + " solns");
            }
            return;
        }
        else{
            boolean flag = false;
            int maxSize = 0, numBuildings = 0;

            for(int i=0;i<factorial(n); ++i){
                flag = false;
                maxSize = 0; numBuildings = 0;
                for(int j=0;j<n;++j) {
                    possibleSoln[level][j] = perms[i][j];
                    for (int before = 0; before < level; ++before) {
                        if (possibleSoln[before][j] == possibleSoln[level][j]) {
                            flag = true;
                            break;
                        }
                    }
                    if (flag)
                        break;
                }
                // Include a check for row sums
                for (int col = 0; col < n; ++col) {
                    if (possibleSoln[level][col] > maxSize) {
                        maxSize = possibleSoln[level][col] ;
                        numBuildings++;
                    }
                }
                if (sky.hints[0][level] != numBuildings) {
                    flag = true;
                    continue;
                }
                // Do same on backwards sum (right)
                numBuildings=0; maxSize=0;
                for (int col = n-1; col >= 0; --col) {
                    if (possibleSoln[level][col] > maxSize) {
                        maxSize = possibleSoln[level][col] ;
                        numBuildings++;
                    }
                }
                if (sky.hints[2][level] != numBuildings) {
                    flag = true;
                    continue;
                }


                if(flag)
                    continue;
                // See if this solution has the same element in same location

                loopR(sky,level+1,n);
            }
        }
    }

    /**
     * The "Driver routine" for generating permutations. This creates a single
     *  array of size n with 1 to n ([1 2 3 4 ... n]) then generates every
     *  permutation of this and stores in "perms".
     * We do it this particular way since one can, say, enter in [1 3 5 7] and
     *  get each permutation of THAT as well, without modifying the recursive
     *  function part of the problem
     * @param n : the size of our array
     */
    void getAllPerms(int n){
        origs = new int[n];
        for(int i=0; i<n; ++i)
            origs[i] = i+1;
        generatePermsR(origs,0);
    }

    /**
     * The recursive part of the permutation generator. Here:
     * https://stackoverflow.com/questions/7537791/understanding-recursion-to-generate-permutations
     * and here:
     *
     * contains some implementations for characters, but have good descriptions
     * of the algorithm. This is what I would base mine on
     * @param x : array that contains a given permutation.
     * @param i : How many parts of the array have been chosen (i=n is "end case")
     */
    public void generatePermsR(int []x, int i){
        // Full permutation generation
        int n = x.length;
        if(i==n){
            for(int j=0;j<n;++j)
                perms[howMany][j] = x[j];
            howMany++;
        }
        else{
            for(int k=i;k<n;++k){
                swap(x,i,k);
                generatePermsR(x,i+1);
                swap(x,i,k);
            }
        }

    }

}

/**
 * Main class. We create hints and size for a known Skyscraper puzzle.
 *  Then run our solver and print out all solutions!
 * Your code should work for n=4 and n=5 (you can test on n=6, but will
 *  get  non-unique solutions.
 *
 */
public class Main {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
//        int n = 5;
//        int hints[][] = {{2,2,1,2,3},{2,2,3,4,1},{1,2,4,3,2},{2,2,2,1,4}};
//        SkyScraper sky = new SkyScraper(hints);
       /* Soln
        1 6 2 3 4 5
        5 4 1 6 2 3
        4 5 3 2 1 6
        2 3 6 1 5 4
        3 2 4 5 6 1
        6 1 5 4 3 2
 */
        int n = 6;
        int hints[][] = {{2,2,3,3,4,1},
                         {3,1,3,2,3,2},
                         {2,2,1,3,2,5},
                         {1,5,2,3,2,3}};
        SkyScraper sky = new SkyScraper(hints);


       /* Soln
        1 5 3 7 6 2 4
        5 1 2 4 7 6 3
        7 4 6 2 3 5 1
        2 7 1 3 5 4 6
        3 6 4 1 2 7 5
        6 3 7 5 4 1 2
        4 2 5 6 1 3 7
         */
//        int n = 7;
//        int hints[][] = {{3,2,1,2,3,2,4},
//                {3,2,3,1,2,3,3},
//                {3,3,4,2,2,4,1},
//                {3,4,2,2,4,2,1}};
////
//        SkyScraper sky = new SkyScraper(hints);

//                *    2   2   3   4   1
//                * 2| 4 | 2 | 3 | 1 | 5 |1
//                * 2| 1 | 5 | 2 | 3 | 4 |2
//                * 1| 5 | 3 | 4 | 2 | 1 |4
//                * 2| 2 | 1 | 5 | 4 | 3 |3
//                * 3| 3 | 4 | 1 | 5 | 2 |2
//                *    2   2   2   1   4
//        int [][] board = {{4,2,3,1,5},{1,5,2,3,4},{5,3,4,2,1},{2,1,5,4,3},{3,4,1,5,2}};
//        for(int [] b : board) {
//            System.out.print("[");
//            for (int r : b) {
//                System.out.print(String.format("%-3d",r));
//            }
//            System.out.println("\b\b]");
//        }
//        System.out.println(sky.checkBoard(board));
        SkyscraperSolver solver = new SkyscraperSolver(n);
        solver.getAllPerms(n);
        System.out.println("Found all permutations...");
        for(int[] pp: solver.perms){
            System.out.print("[");
            for(int p:pp)
                System.out.print(p+",");
            System.out.println("\b]");
        }

        solver.solver(sky, n);
        long stop = System.currentTimeMillis();
        System.out.println("-- " + solver.allSolns.size()+" Possible Solutions --");
        for(int [][]p : solver.allSolns){
            for (int[] pp : p) {
                System.out.print("(");
                for (int ppp : pp)
                    System.out.print(ppp + ",");
                System.out.println("\b)");
            }
            System.out.println("-----------------------");

        }
        System.out.println("Elapsed time: "+(stop-start)/1000.0 + " secs");
    }
}
